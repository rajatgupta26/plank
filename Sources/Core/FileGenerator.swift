//
//  FileGenerator.swift
//  Plank
//
//  Created by Rahul Malik on 7/23/15.
//  Copyright Â© 2015 Rahul Malik. All rights reserved.
//

import Foundation

public typealias GenerationParameters = [GenerationParameterType:String]

let formatter = DateFormatter()
let date = Date()

public enum GenerationParameterType {
    case classPrefix
    case recursive
    case includeRuntime
}

public enum Languages: String {
    case objectiveC = "objc"
    case swift = "swift"
}

public protocol FileGeneratorManager {
    static func filesToGenerate(descriptor: SchemaObjectRoot, generatorParameters: GenerationParameters) -> [FileGenerator]
    static func runtimeFiles() -> [FileGenerator]
}

// Object containing file content(String) and name
public protocol FileGenerator {
    func renderFile() -> String
    var fileName: String { mutating get }
}

// Extension of FileGenerator with generic functions
extension FileGenerator {

    // The comment header to be added at the top of file
    func renderCommentHeader() -> String {
        formatter.dateStyle = DateFormatter.Style.long
        formatter.timeStyle = .medium
        formatter.timeZone = TimeZone(identifier: "UTC")
        formatter.dateFormat = "MM-dd-yyyy 'at' HH:mm:ss"

        var copy = self

        let header = [
            "//",
            "//  \(copy.fileName)",
            "//  Autogenerated by plank",
            "//",
            "//  DO NOT EDIT - EDITS WILL BE OVERWRITTEN",
            "//  @generated",
            "//"
        ]

        return header.joined(separator: "\n")
    }
}

// Default implementation of FileGeneratorManager protocol functions
extension FileGeneratorManager {
    func generateFile(_ schema: SchemaObjectRoot, outputDirectory: URL, generationParameters: GenerationParameters) {
        // 'filesToGenerate' generates FileGenerators for files specified by schema with given generation parameters.
        for var file in Self.filesToGenerate(descriptor: schema, generatorParameters: generationParameters) {
            // Get the content string for file from FileGenerator
            let fileContents = file.renderFile() + "\n" // Ensure there is exactly one new line at the end of the file
            do {
                // Try writing to disk at given file url
                try fileContents.write(
                    to: URL(string: file.fileName, relativeTo: outputDirectory)!,
                    atomically: true,
                    encoding: String.Encoding.utf8)
            } catch {
                assert(false)
            }
        }
    }

    public func generateFileRuntime(outputDirectory: URL) {
        let files: [FileGenerator] = Self.runtimeFiles()
        for var file in files {
            let fileContents = file.renderFile() + "\n" // Ensure there is exactly one new line a the end of the file
            do {
                try fileContents.write(
                    to: URL(string: file.fileName, relativeTo: outputDirectory)!,
                    atomically: true,
                    encoding: String.Encoding.utf8)
            } catch {
                assert(false)
            }
        }
    }
}

func generator(forLanguage language: Languages) -> FileGeneratorManager {
    switch language {
    case .objectiveC:
        return ObjectiveCFileGenerator()
    case .swift:
        return SwiftFileGenerator()
    }
}

public func generateFileRuntime(outputDirectory: URL) {
    let files: [FileGenerator] = [ObjCRuntimeHeaderFile(), ObjCRuntimeImplementationFile()]
    for var file in files {
        let fileContents = file.renderFile() + "\n" // Ensure there is exactly one new line a the end of the file
        do {
            try fileContents.write(
                to: URL(string: file.fileName, relativeTo: outputDirectory)!,
                atomically: true,
                encoding: String.Encoding.utf8)
        } catch {
            assert(false)
        }
    }
}

public func loadSchemasForUrls(urls: Set<URL>) -> [(URL, Schema)] {
    return urls.map { ($0, FileSchemaLoader.sharedInstance.loadSchema($0)) }
}

public func generateDeps(urls: Set<URL>) {
    let urlSchemas = loadSchemasForUrls(urls: urls)
    let deps = Set(urlSchemas.map { (url, schema) -> String in
        ([url] + schema.deps()).map { $0.path }.joined(separator: ":")
    })
    deps.forEach { dep in
        print(dep)
    }
}

public func generateFiles(urls: Set<URL>, outputDirectory: URL, generationParameters: GenerationParameters, forLanguages languages: [Languages]) {
    // Generate files with given schema urls, generation parameters and language
    
    // Get the generator object for language
    let fileGenerators: [FileGeneratorManager] = languages.map(generator)
    
    // Load schema from url
    _ = loadSchemasForUrls(urls: urls)
    
    // Process schemas one by one
    var processedSchemas = Set<URL>([])
    repeat {
        _ = FileSchemaLoader.sharedInstance.refs.map({ (url: URL, schema: Schema) -> Void in
            if processedSchemas.contains(url) {
                // Return if schema is already processed
                return
            }
            // Else enter schema to processed schemas
            processedSchemas.insert(url)
            switch schema {
            case .object(let rootObject):
                // Root schema must be of type object
                fileGenerators.forEach { generator in
                    // Ask each generator to generate file with schema.
                    // This is the point where each generator can have different processing logic based on requirements.
                    // Objective C generator generates, h and m files, builder for the object, NSCoding compliant code and some other things.
                    // Refer the SchemaObjectRoot and other Schema model structs for reference and implement code for required functionality accordingly.
                    generator.generateFile(rootObject,
                                           outputDirectory: outputDirectory,
                                           generationParameters: generationParameters)
                }
            default:
                assert(false, "Incorrect Schema for root.") // TODO Better error message.
            }
        })
    } while (
        generationParameters[.recursive] != nil &&
        processedSchemas.count != FileSchemaLoader.sharedInstance.refs.keys.count)
    if generationParameters[.includeRuntime] != nil {
        fileGenerators.forEach {
            $0.generateFileRuntime(outputDirectory: outputDirectory)
        }
    }
}
